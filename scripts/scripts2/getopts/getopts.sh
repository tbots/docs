#!/bin/bash
#
# In general the call to getopts need to be performed several times. Each time it will use the next positional parameter and a possible
# argument, if parsable, and provide it to you.
#
# getopts will not change the set of positional parameters. If we want to shift them, it must be done manually.
#
# shift $((OPTIND-1))					# $(( evaluate ))
# now do something with $@
#
# Since getopts sets an exit status of FALSE when there's nothing left to parse, it's easy to use in while-loop
#
# while getopts ...
# do
# 	...
# done
#
# getopts will parse options and their possible arguments. It will stop parsing on the first non-option argument (a string
# that doesn't begin with a hyphen `-' that isn't an argument for any option in front of it. It will also stop parsing when it
# sees the -- (double-hyphen), which means end of options.
#
# OPTIND				holds the index to the next argument to be processed. This is how getopts "remembers" its own status between
# 							invocations.
# 
# OPTARG				set to any argument for an option found by getopts. It also contains the option flag of an unknown option.
#
# OPTERR				(Values 0 or 1) indicates if Bash should display error message generated by getopts builtin. The value is initialized to
# 							1 on every shell startup - so be sure to always set it to 0 if you don't want to see annoying messages! OPTERR is not
# 							specified by POSIX for the getopts builtin utility - only for the C getopt() function in unistd.h (opterr). OPTERR is
#								OPTERR is bash-specific and not supported by shells such as ksh93, mksh, zsh, or dash
#
# while getopts ":a" opt
# do
# 	case $opt in					# character read returns in $opt
# 		a)
# 			echo "-a was triggered!" >&2
# 			;;
# 		\?)
# 			echo "Invalid option: -$OPTARG" >&2
# 			;;
# 	esac
# done	

# Report variable values on their init
echo "OPTIND: $OPTIND"
echo "OPTERR: $OPTERR"

#
# Print all the arguments:
#

while [ -n "${!OPTIND}" ]
# Loop while OPTIND is points indirectly on non-empty positional parameter
do
	# Report current element processed.
	echo "ARG #$OPTIND: ${!OPTIND}"

	# Run getopts on this element.
	while getopts "um" option
	do
		# Report current variables status
		echo -e "\n Inside the loop\n"
		echo "OPTIND: $OPTIND"
		echo "OPTARG: $OPTARG"

		case $option in
			
			# user.name
			u)
				echo -ne "user.name:\t "; git config user.name;;

			# invalid option read
			\?)
			 echo "Invalid option -$OPTARG" >&2;;
		esac
	done

	# Report current variables status
	echo -e "\n Outside the loop\n"
	echo "OPTIND: $OPTIND"
	echo "OPTARG: $OPTARG"
	
	let "((OPTIND += 1))"
done
