
	[PLAYBOOKS]
		
		Hosts and Users
			
		For each play in a playbook, you get to choose which machines in your infrastructure to target and what remote user to complete the steps (tasks) as.
		you can become another user, different from the user that is logged into the machine (remote_user), this is done using existing privilege escalation
		tools.

		The generic form of playbook is as follows:

			hosts:		  			a list of one or more groups or host patterns, separated by colons
			remote_user:			name of the user account
			order:						inventory|reverse_inventory|
			gather_facts: 
      vars:
        <list>:
          <item>: <value>

        <list>:
          - {{ list }}

			tasks:
				- <task>:
					<variable>: <value>

		
	 Variables:

		inventory_hostname

    ansible -m setup <host>
	 

	 examples:

	 	- hosts: all
			gather_facts: false
			tasks:
				- debug:
					var: inventory_hostname

	 looping constructs.

		 	key: "{{ lookup( 'file', item ) }}"			# look like item is the default handler for the iterated item
		loop:
			- /path/to/file1
			- /path/to/file2

			key: "{{ item }}"
		with_file:
			- /path/to/file1
			- /path/to/file2

			key: "{{ lookup( 'pipe', 'cat /home/osergiyuk/.ssh/id_rsa*.pub' ) }}"

		user:
			name: "{{ item.name }}"
		with_flattened: "[ {{ansible}}, {{admins}} ]" 

		admins:
			- "{{ osergiyuk }}"

		osergiyuk:
			name: "Oleg"

	[!] how to achieve it all with debug module?

 [INVOCATION]

	Ansible by default assumes that SSH keys are used for authentication. Use --ask-pass for the password prompt and --ask-become-pass for the sudo(1).
	Inventory file (can be specified manually with -i,--inventory or --inventory-file (deprecated) options as a single file or a comma-separated list)


 	Define and run a single task 'playbook' against a set of hosts.

	 ansible HOST... [OPTIONS...]			

	HOST can be a group name, individual host or one of the `all', `localhost' keywords. To see the list of the matching hosts:
    
    ansible -i file --list-hosts <pattern> 


  Run a playbook executing defined tasks on the target hosts.

   ansible-playbook [OPTIONS...] PLAYBOOK.YML...

  Examples:

   ansible-playbook --inventory=~/docs/ansible/hosts --list-hosts users.yml
	Exmaples:
		
		ansible all -m command -u user -b --become-user user
		ansible all -i localhost, -m debug -a "msg={{ 'password' | password_hash('sha512', 'salt') }}"
		ansible localhost -m ping -e 'ansyble-python-interpreter=/usr/bin/python'
		ansible --list-hosts '*' --limit='10.*'

		-m,--module-name		module name
		-a,--args						module arguments
		-u,--user   				remote user
		-b,--become					run operations with become (does not imply password prompting)
		--become-user				run operations as this user (default=root)
		-e,--extra-vars			set additional variables as key=value or YAML/JSON
		-i,--inventory-file	specify inventory host path (default=/etc/ansible/hosts) or comma-separated host
		-f,--forks FORKS		specify number of parallel processes to use (default=5)
    --limit=SUBSET      further limit selected hosts to an additional pattern

    --start-at-task

    --step

		--syntax-check
				Perform a syntax check on the playbook but do not execute it

	[MODULES]
		
		yum
		apt
		debug
		user
		file
		git
		ping
		service
		webservers

 [ROLES]

  ansible-galaxy init base-line
	 
	 ./defaults -> main.yml				
	 ./files ->
	 ./templates
	 ./handlers
	 ./meta
	 ./tasks -> main.yml
	 ./vars
	
	The 'defaults' directory lists variable defaults that take lower precedence; if a variable is defined nowhere else, the
	definition given in defaults/main.yml will be used.

	The 'files' and 'templates' directories contain affiliated files and templates that are used within the role.

	The 'handlers' directory is used to store tasks that may be flagged during a play to run at the play's completition. 

	The 'meta' directory contains authorship information which is useful to publish a role on galaxy.ansible.com. It may 
	also be used to define role dependencies. Role dependency allows to require that other roles be installed prior to the 
	role in question.

	The 'tasks' directory is where most of your role will be written. This directory includes all the tasks that role will run. 
	Ideally, each logically related series of tasks would be laid out in their own files, and simply included through the main.yml
	file in the tasks directory.

	The 'vars' directory is where necessary valiables for your roles are defined. They are ment for internal use only.

	 Variable precedence:

	 /etc/ansible/host_vars/<host_name>
	  > /etc/ansible/roles/<role_name>/vars/main.yml?


	*task syntax*
		copy:
			src=./file/<filename> <-

		template: 

			src=<path_to_j2_template>

				
			dest=<remote_path>

			owner=
				Name of the user that should own a the file/directory, as would be fed to chown?try root:

			mode=
				
		service:
			state:
			name:
			enabled:


		when: ( ansible_os_family=Debian|CentOS AND
						ansible_distribution_majon_version == '7' AND
					  ansible_fqdn [!]= 'fqdn' )



	/etc/ansible/hosts file syntax examples


	 [group_name]
	 host[:port]

	 [range_start:range_end]

	 localhost              ansible_connection=local
	 other1.example.com     ansible_connection=ssh        ansible_user=mpdehaan
	 host1 http_port=80 maxRequestsPerChild=808

	 Group variables

	 [atlanta]
	 server1
	 server2
	 
	 [berlin]
	 b1
	 b2

	 [atlanta:vars]
	 ansible_connection=local
	 ansible_user=root
	 http_port=80
	 maxRequestsPerChild=808]
	 ntp_server=ntp.atlanta.example.com
	 proxy=proxy.atlanta.example.com

	 [all:children]
	 atlanta
	 berlin

	 [all:vars]
	 some_server=server1	DEFINE
	 halon_system_timeout=30
	 self_destruct_countdown=60
	 escape_pods=2


 Examples:

 Copy files:
 	-m copy -a 'src=/src dest=/dest'

 Change file permissions:

	-m file -a 'dest=/dest mode=600 owner= group'
	-m file -a 'dest=/dir state=absent'

	state			directory	//create directory

	Limited background operations

	ansible-galaxy 

			

		The things listed in the notify section of a task are called handlers. Note 'listen' attribute.

	All or * are equivalent	

	group:second_group
	group:!second_group

	group:second_group:&third_group:!fourh_group
		
		all machines from the group and second_group are to be managed if in third group but not in fourh_group

	group[-1] group[1:] 

	~extended_regexp

	--limit string
	@ assumes filename
